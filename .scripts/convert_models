#!/usr/bin/env python3

from pathlib import Path
import json
from typing import Dict, Tuple, TypedDict, Literal, Optional, Any
from dataclasses import dataclass
import logging
import argparse

# Configure logging
logger = logging.getLogger(__name__)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s.%(msecs)03d - %(levelname)s - %(message)s',
    datefmt="%Y-%m-%dT%H:%M:%S",
)

# Type Definitions
class ServiceTrait(TypedDict):
    sdkId: str

class BaseTrait(TypedDict, total=False):
    pass

class BaseShape(TypedDict):
    type: str
    traits: Dict[str, BaseTrait]

class ServiceShape(BaseShape):
    type: Literal['service']
    version: str
    traits: Dict[str, ServiceTrait]

class Model(TypedDict):
    shapes: Dict[str, BaseShape | ServiceShape]

@dataclass
class Model:
    json: dict
    sdk_id: str
    service_version: str


# Constants
SERVICE_TYPE = 'service'
SERVICE_TRAIT = 'aws.api#service'

def is_service_shape(shape: Optional[BaseShape]) -> bool:
    """Check if the shape is a service shape."""
    return shape is not None and shape.get('type') == SERVICE_TYPE

def sanitize_sdk_id(sdk_id: str) -> str:
    """Sanitize the SDK ID by removing service/client/api suffixes."""
    for suffix in ['service', 'client', 'api']:
        if sdk_id.lower().endswith(suffix.lower()):
            sdk_id = sdk_id[:-len(suffix)]
    return sdk_id.strip()

def sanitize_service_shape_id(shape_id: str, sdk_id: str) -> str:
    """Transform the service shape ID using the SDK ID."""
    service_name = ''.join(
        word.capitalize() 
        for word in sdk_id.split()
    )

    if not service_name:
        logger.error(f"Failed to determine service name from SDK ID: {sdk_id}")
        raise ValueError(f"Could not determine serviceName from '{sdk_id}'")

    try:
        namespace, _ = shape_id.split("#")
    except ValueError:
        logger.error(f"Invalid shape ID format: {shape_id}")
        raise ValueError(f"Could not determine namespace from '{shape_id}'")

    return f"{namespace}#{service_name}"

def load_overrides(override_path: Optional[Path]) -> Dict[str, dict]:
    """
    Load JSON overrides from a file.
    
    The override file should be structured as:
    {
        "<sdkId>": {
            "key": "value",
            ...
        }
    }
    
    Args:
        override_path: Path to JSON file containing overrides
    Returns:
        Dictionary of overrides keyed by service ID
    """
    if not override_path or not override_path.is_file:
        return {}
        
    try:
        return json.loads(override_path.read_text(encoding='utf-8'))
    except Exception as e:
        logger.error(f"Failed to load overrides from {override_path}: {str(e)}")
        raise

def apply_overrides(model_json: dict, overrides: dict) -> dict:
    """
    Apply overrides to the model JSON by deep merging.
    
    Args:
        model_json: Original model JSON
        overrides: Override values to apply
    Returns:
        Updated model JSON with overrides applied
    """
    def deep_merge(base: dict, update: dict) -> dict:
        for key, value in update.items():
            if key in base and isinstance(base[key], dict) and isinstance(value, dict):
                deep_merge(base[key], value)
            else:
                base[key] = value
        return base
    
    return deep_merge(model_json.copy(), overrides)

def handle_model(model_path: Path, overrides: Dict[str, dict] = None) -> Model:
    """
    Parse and process a model.json file.
    
    Args:
        model_path: Path to the model.json file
        overrides: Optional dictionary of overrides keyed by SDK ID
    Returns:
        Model with processed data
    """
    # Load and parse the model file
    smithy_model_json = json.loads(model_path.read_text(encoding='utf-8'))
    
    # Find the service shape
    service_shape = None
    sdk_id = None
    
    for shape_id, shape in smithy_model_json.get('shapes', {}).items():
        if shape.get('type') == 'service':
            service_shape = shape
            sdk_id = shape.get('traits', {}).get('aws.api#service', {}).get('sdkId')
            break
    
    if not service_shape or not sdk_id:
        raise ValueError("Could not find service shape with sdkId in model")
        
    # Apply any overrides for this service
    if overrides and sdk_id in overrides:
        logger.info(f"  Applying overrides for SDK ID: {sdk_id}")
        smithy_model_json = apply_overrides(smithy_model_json, overrides[sdk_id])
            
        # Re-fetch service shape as it might have been modified
        for shape_id, shape in smithy_model_json.get('shapes', {}).items():
            if shape.get('type') == 'service':
                service_shape = shape
                break
    
    return Model(
        json=smithy_model_json,
        sdk_id=sdk_id,
        service_version=service_shape['version']
    )

def process_models(source_dir: Path, dest_dir: Path, override_path: Optional[Path] = None) -> None:
    """
    Walk through source directory and process all model.json files.
    
    Args:
        source_dir: Path to directory containing source models
        dest_dir: Path to directory where transformed models should be written
        override_path: Optional path to JSON file containing model overrides
    """
    logger.info(f"Processing models from {source_dir}")
    logger.info(f"Writing output to {dest_dir}")

    # Load overrides if provided
    overrides = load_overrides(override_path)
    if overrides:
        logger.info(f"Loaded overrides for services: {', '.join(overrides.keys())}")

    # Ensure source directory exists
    if not source_dir.exists():
        logger.error(f"Source directory does not exist: {source_dir}")
        raise FileNotFoundError(f"Source directory not found: {source_dir}")

    # Track success and failure counts
    processed = 0
    failed = 0

    # Walk through the source directory
    for model_path in source_dir.rglob('model.json'):
        try:
            logger.info(f"Processing {model_path}")
            process_model(model_path, dest_dir, overrides)
            processed += 1
            
        except Exception as e:
            logger.error(f"Failed to process {model_path}: {str(e)}", exc_info=True)
            failed += 1

    # Log summary
    logger.info(f"Processing complete. Successfully processed: {processed}, Failed: {failed}")
    if failed > 0:
        logger.warning("Some models failed to process. Check logs for details.")

def process_model(input_path: Path, dest_dir: Path, overrides: Dict[str, dict]) -> None:
    """
    Process a single model.json file and write the transformed version.
    
    Args:
        input_path: Path to the input model.json file
        dest_dir: Path to destination directory
        overrides: Dictionary of model overrides keyed by SDK ID
    """
    logger.info(f"  Input path: {input_path}")

    try:
        # Process the model with overrides
        model = handle_model(input_path, overrides)
        
        # Create the service ID and file name
        service_id = model.sdk_id.lower().replace(' ', '-')
        file_name = f"{service_id}-{model.service_version}.json"
        
        # Create the new directory structure and file path
        output_path = dest_dir / service_id / 'service' / model.service_version / file_name
        
        # Ensure output directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Write the transformed model
        output_path.write_text(
            json.dumps(model.json, indent=2),
            encoding='utf-8'
        )
        
        logger.info(f"  SDK ID: {model.sdk_id}")
        logger.info(f"  Service Version: {model.service_version}")
        logger.info(f"  Output: {output_path}")
        logger.info("=" * 80)
        
    except Exception as e:
        logger.error(f"  Failed to process model: {str(e)}", exc_info=True)
        logger.info("=" * 80)
        raise

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Transform Smithy model.json files from source to destination directory."
    )

    parser.add_argument(
        "--source-dir",
        "-s",
        type=Path,
        required=True,
        help="Source directory containing model.json files"
    )
    
    parser.add_argument(
        "--dest-dir",
        "-d",
        type=Path,
        required=True,
        help="Destination directory for transformed models"
    )
    
    parser.add_argument(
        "--overrides",
        "-o",
        type=Path,
        help="JSON file containing model overrides (keyed by `Sdk ID`)"
    )
    args = parser.parse_args()
    
    process_models(args.source_dir, args.dest_dir, args.overrides)
